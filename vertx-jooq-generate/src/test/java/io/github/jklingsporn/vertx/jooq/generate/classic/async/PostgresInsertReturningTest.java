package io.github.jklingsporn.vertx.jooq.generate.classic.async;

import generated.classic.reactive.regular.vertx.tables.pojos.Something;
import generated.classic.reactive.regular.vertx.tables.pojos.Somethingcomposite;
import generated.classic.reactive.regular.vertx.tables.records.SomethingRecord;
import generated.classic.reactive.regular.vertx.tables.records.SomethingcompositeRecord;
import io.github.jklingsporn.vertx.jooq.generate.AbstractPostgresInsertReturningTest;
import io.vertx.core.AsyncResult;
import io.vertx.core.Handler;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import org.jooq.Record2;
import org.jooq.Table;
import org.jooq.UpdatableRecord;
import org.junit.Assert;
import org.junit.Test;

import java.time.LocalDateTime;
import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.function.Function;

/**
 * @author jensklingsporn
 */
public class PostgresInsertReturningTest extends AbstractPostgresInsertReturningTest {

    @Test
    public void insertReturningAutogeneratedIdShouldReturnId() throws InterruptedException {
        Random random = new Random();
        SomethingRecord something = new SomethingRecord();
        something.setSomedouble(random.nextDouble());
        something.setSomeregularnumber(random.nextInt());
        something.setSomehugenumber(random.nextLong());
        something.setSomejsonarray(new JsonArray().add(1).add(2).add(3));
        something.setSomejsonobject(new JsonObject().put("key", "value"));
        something.setSomesmallnumber((short) random.nextInt(Short.MAX_VALUE));
        something.setSomestring("my_string");
        //someEnum has a default value and does not need to be set
        something.setSometimestamp(LocalDateTime.now());
        insertReturningShouldSucceed(generated.classic.reactive.regular.vertx.tables.Something.SOMETHING, something, Something::new, Integer.class);
    }

    @Test
    public void insertReturningWithIdShouldReturnId() throws InterruptedException {
        Random random = new Random();
        SomethingRecord something = new SomethingRecord();
        something.setSomeid(random.nextInt());
        something.setSomedouble(random.nextDouble());
        something.setSomeregularnumber(random.nextInt());
        something.setSomehugenumber(random.nextLong());
        something.setSomejsonarray(new JsonArray().add(1).add(2).add(3));
        something.setSomejsonobject(new JsonObject().put("key", "value"));
        something.setSomesmallnumber((short) random.nextInt(Short.MAX_VALUE));
        something.setSomestring("my_string");
        //someEnum has a default value and does not need to be set
        something.setSometimestamp(LocalDateTime.now());
        insertReturningShouldSucceed(generated.classic.reactive.regular.vertx.tables.Something.SOMETHING, something, Something::new, Integer.class);
    }

    @Test
    public void insertReturningCompositeKeyShouldReturnId() throws InterruptedException {
        Random random = new Random();
        insertReturningShouldSucceed(generated.classic.reactive.regular.vertx.tables.Somethingcomposite.SOMETHINGCOMPOSITE,new SomethingcompositeRecord().setSomejsonobject(new JsonObject()).setSomeid(random.nextInt()).setSomesecondid(random.nextInt()), Somethingcomposite::new, Record2.class);
    }

    @Test
    public void insertReturningCompositeKeyNotSetShouldFail() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        runInsertReturning(generated.classic.reactive.regular.vertx.tables.Somethingcomposite.SOMETHINGCOMPOSITE, new SomethingcompositeRecord(), Somethingcomposite::new, latch, res->{
            Assert.assertTrue(res.failed());
            latch.countDown();
        });
    }

    private <R extends UpdatableRecord<R>,P,T> void insertReturningShouldSucceed(Table<R> table, R record, Function<JsonObject, P> pojoMapper, Class<T> clazz) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        runInsertReturning(table, record, pojoMapper, latch, res -> {
            if (res.failed()) {
                Assert.fail(res.cause().getMessage());
            } else {
                Assert.assertTrue(clazz.isInstance(res.result()));
            }
            latch.countDown();
        });
    }

    private <R extends UpdatableRecord<R>,P,T> void runInsertReturning(Table<R> table, R record, Function<JsonObject, P> pojoMapper, CountDownLatch latch, Handler<AsyncResult<T>> resultHandler) throws InterruptedException {
//        Configuration configuration = new DefaultConfiguration();
//        configuration.set(SQLDialect.POSTGRES);
//        AsyncClassicQueryExecutor<R,P,T> queryExecutor = new AsyncClassicQueryExecutor<>(
//                configuration,
//                AsyncDatabaseClientProvider.getInstance().getClient(Credentials.POSTGRES),
//                pojoMapper,
//                table,
//                false
//        );
////        AsyncCompletableFutureQueryExecutor2 asyncCompletableFutureQueryExecutor2 = new AsyncCompletableFutureQueryExecutor2(AsyncDatabaseClientProvider.getInstance().getVertx(), AsyncDatabaseClientProvider.getInstance().getClient(Credentials.POSTGRES), configuration);
////        CompletableFuture<List<Record1<Long>>> manyRaw = asyncCompletableFutureQueryExecutor2.findMany(dslContext -> dslContext.select(Tables.SOMETHING.SOMEHUGENUMBER).from(Tables.SOMETHING));
//
//        Future<T> insertReturning = queryExecutor.insertReturning(dslContext -> dslContext
//                .insertInto(table)
//                .set(record)
//                .returning(table.getPrimaryKey().getFieldsArray())
//                , keyMapper(table, configuration));
//        insertReturning.setHandler(resultHandler);
//        Assert.assertTrue(latch.await(1, TimeUnit.SECONDS));
    }

}
